"use strict";var Ss=Object.defineProperty,Ps=Object.defineProperties;var Is=Object.getOwnPropertyDescriptors;var Fn=Object.getOwnPropertySymbols;var Ms=Object.prototype.hasOwnProperty,Es=Object.prototype.propertyIsEnumerable;var kn=Math.pow,vn=(jt,Tt,nt)=>Tt in jt?Ss(jt,Tt,{enumerable:!0,configurable:!0,writable:!0,value:nt}):jt[Tt]=nt,Be=(jt,Tt)=>{for(var nt in Tt||(Tt={}))Ms.call(Tt,nt)&&vn(jt,nt,Tt[nt]);if(Fn)for(var nt of Fn(Tt))Es.call(Tt,nt)&&vn(jt,nt,Tt[nt]);return jt},an=(jt,Tt)=>Ps(jt,Is(Tt));(self.webpackChunk=self.webpackChunk||[]).push([[5539],{90980:function(jt,Tt,nt){nt.d(Tt,{B:function(){return Bs}});var h=nt(99477);const Dt=0,Kt=1,St=2,dt=0,ut=1,v=2,D=1.25,X=1,Z=6*4+4+4,$=65535,N=Math.pow(2,-24),O=Symbol("SKIP_GENERATION");function j(n){return n.index?n.index.count:n.attributes.position.count}function Y(n){return j(n)/3}function ot(n,t=ArrayBuffer){return n>65535?new Uint32Array(new t(4*n)):new Uint16Array(new t(2*n))}function st(n,t){if(!n.index){const e=n.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=ot(e,s);n.setIndex(new h.BufferAttribute(i,1));for(let a=0;a<e;a++)i[a]=a}}function tt(n){const t=Y(n),e=n.drawRange,s=e.start/3,i=(e.start+e.count)/3,a=Math.max(0,s),o=Math.min(t,i)-a;return[{offset:Math.floor(a),count:Math.floor(o)}]}function it(n){if(!n.groups||!n.groups.length)return tt(n);const t=[],e=new Set,s=n.drawRange,i=s.start/3,a=(s.start+s.count)/3;for(const c of n.groups){const r=c.start/3,d=(c.start+c.count)/3;e.add(Math.max(i,r)),e.add(Math.min(a,d))}const o=Array.from(e.values()).sort((c,r)=>c-r);for(let c=0;c<o.length-1;c++){const r=o[c],d=o[c+1];t.push({offset:Math.floor(r),count:Math.floor(d-r)})}return t}function Pt(n){if(n.groups.length===0)return!1;const t=Y(n),e=it(n).sort((a,o)=>a.offset-o.offset),s=e[e.length-1];s.count=Math.min(t-s.offset,s.count);let i=0;return e.forEach(({count:a})=>i+=a),t!==i}function It(n,t,e,s,i){let a=1/0,o=1/0,c=1/0,r=-1/0,d=-1/0,l=-1/0,p=1/0,f=1/0,y=1/0,B=-1/0,L=-1/0,I=-1/0;for(let A=t*6,m=(t+e)*6;A<m;A+=6){const w=n[A+0],T=n[A+1],b=w-T,E=w+T;b<a&&(a=b),E>r&&(r=E),w<p&&(p=w),w>B&&(B=w);const S=n[A+2],C=n[A+3],F=S-C,k=S+C;F<o&&(o=F),k>d&&(d=k),S<f&&(f=S),S>L&&(L=S);const W=n[A+4],U=n[A+5],H=W-U,Q=W+U;H<c&&(c=H),Q>l&&(l=Q),W<y&&(y=W),W>I&&(I=W)}s[0]=a,s[1]=o,s[2]=c,s[3]=r,s[4]=d,s[5]=l,i[0]=p,i[1]=f,i[2]=y,i[3]=B,i[4]=L,i[5]=I}function Vt(n,t=null,e=null,s=null){const i=n.attributes.position,a=n.index?n.index.array:null,o=Y(n),c=i.normalized;let r;t===null?(r=new Float32Array(o*6*4),e=0,s=o):(r=t,e=e||0,s=s||o);const d=i.array,l=i.offset||0;let p=3;i.isInterleavedBufferAttribute&&(p=i.data.stride);const f=["getX","getY","getZ"];for(let y=e;y<e+s;y++){const B=y*3,L=y*6;let I=B+0,A=B+1,m=B+2;a&&(I=a[I],A=a[A],m=a[m]),c||(I=I*p+l,A=A*p+l,m=m*p+l);for(let w=0;w<3;w++){let T,b,E;c?(T=i[f[w]](I),b=i[f[w]](A),E=i[f[w]](m)):(T=d[I+w],b=d[A+w],E=d[m+w]);let S=T;b<S&&(S=b),E<S&&(S=E);let C=T;b>C&&(C=b),E>C&&(C=E);const F=(C-S)/2,k=w*2;r[L+k+0]=S+F,r[L+k+1]=F+(Math.abs(S)+F)*N}}return r}function J(n,t,e){return e.min.x=t[n],e.min.y=t[n+1],e.min.z=t[n+2],e.max.x=t[n+3],e.max.y=t[n+4],e.max.z=t[n+5],e}function At(n){n[0]=n[1]=n[2]=1/0,n[3]=n[4]=n[5]=-1/0}function kt(n){let t=-1,e=-1/0;for(let s=0;s<3;s++){const i=n[s+3]-n[s];i>e&&(e=i,t=s)}return t}function xt(n,t){t.set(n)}function ee(n,t,e){let s,i;for(let a=0;a<3;a++){const o=a+3;s=n[a],i=t[a],e[a]=s<i?s:i,s=n[o],i=t[o],e[o]=s>i?s:i}}function yt(n,t,e){for(let s=0;s<3;s++){const i=t[n+2*s],a=t[n+2*s+1],o=i-a,c=i+a;o<e[s]&&(e[s]=o),c>e[s+3]&&(e[s+3]=c)}}function _t(n){const t=n[3]-n[0],e=n[4]-n[1],s=n[5]-n[2];return 2*(t*e+e*s+s*t)}const Ct=32,Zt=(n,t)=>n.candidate-t.candidate,pt=new Array(Ct).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Rt=new Float32Array(6);function Wt(n,t,e,s,i,a){let o=-1,c=0;if(a===Dt)o=kt(t),o!==-1&&(c=(t[o]+t[o+3])/2);else if(a===Kt)o=kt(n),o!==-1&&(c=oe(e,s,i,o));else if(a===St){const r=_t(n);let d=D*i;const l=s*6,p=(s+i)*6;for(let f=0;f<3;f++){const y=t[f],I=(t[f+3]-y)/Ct;if(i<Ct/4){const A=[...pt];A.length=i;let m=0;for(let T=l;T<p;T+=6,m++){const b=A[m];b.candidate=e[T+2*f],b.count=0;const{bounds:E,leftCacheBounds:S,rightCacheBounds:C}=b;for(let F=0;F<3;F++)C[F]=1/0,C[F+3]=-1/0,S[F]=1/0,S[F+3]=-1/0,E[F]=1/0,E[F+3]=-1/0;yt(T,e,E)}A.sort(Zt);let w=i;for(let T=0;T<w;T++){const b=A[T];for(;T+1<w&&A[T+1].candidate===b.candidate;)A.splice(T+1,1),w--}for(let T=l;T<p;T+=6){const b=e[T+2*f];for(let E=0;E<w;E++){const S=A[E];b>=S.candidate?yt(T,e,S.rightCacheBounds):(yt(T,e,S.leftCacheBounds),S.count++)}}for(let T=0;T<w;T++){const b=A[T],E=b.count,S=i-b.count,C=b.leftCacheBounds,F=b.rightCacheBounds;let k=0;E!==0&&(k=_t(C)/r);let W=0;S!==0&&(W=_t(F)/r);const U=X+D*(k*E+W*S);U<d&&(o=f,d=U,c=b.candidate)}}else{for(let w=0;w<Ct;w++){const T=pt[w];T.count=0,T.candidate=y+I+w*I;const b=T.bounds;for(let E=0;E<3;E++)b[E]=1/0,b[E+3]=-1/0}for(let w=l;w<p;w+=6){let E=~~((e[w+2*f]-y)/I);E>=Ct&&(E=Ct-1);const S=pt[E];S.count++,yt(w,e,S.bounds)}const A=pt[Ct-1];xt(A.bounds,A.rightCacheBounds);for(let w=Ct-2;w>=0;w--){const T=pt[w],b=pt[w+1];ee(T.bounds,b.rightCacheBounds,T.rightCacheBounds)}let m=0;for(let w=0;w<Ct-1;w++){const T=pt[w],b=T.count,E=T.bounds,C=pt[w+1].rightCacheBounds;b!==0&&(m===0?xt(E,Rt):ee(E,Rt,Rt)),m+=b;let F=0,k=0;m!==0&&(F=_t(Rt)/r);const W=i-m;W!==0&&(k=_t(C)/r);const U=X+D*(F*m+k*W);U<d&&(o=f,d=U,c=T.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${a} used.`);return{axis:o,pos:c}}function oe(n,t,e,s){let i=0;for(let a=t,o=t+e;a<o;a++)i+=n[a*6+s*2];return i/e}class de{constructor(){this.boundingData=new Float32Array(6)}}function Ne(n,t,e,s,i,a){let o=s,c=s+i-1;const r=a.pos,d=a.axis*2;for(;;){for(;o<=c&&e[o*6+d]<r;)o++;for(;o<=c&&e[c*6+d]>=r;)c--;if(o<c){for(let l=0;l<3;l++){let p=t[o*3+l];t[o*3+l]=t[c*3+l],t[c*3+l]=p}for(let l=0;l<6;l++){let p=e[o*6+l];e[o*6+l]=e[c*6+l],e[c*6+l]=p}o++,c--}else return o}}function Fe(n,t,e,s,i,a){let o=s,c=s+i-1;const r=a.pos,d=a.axis*2;for(;;){for(;o<=c&&e[o*6+d]<r;)o++;for(;o<=c&&e[c*6+d]>=r;)c--;if(o<c){let l=n[o];n[o]=n[c],n[c]=l;for(let p=0;p<6;p++){let f=e[o*6+p];e[o*6+p]=e[c*6+p],e[c*6+p]=f}o++,c--}else return o}}function $t(n,t){return t[n+15]===65535}function Mt(n,t){return t[n+6]}function Lt(n,t){return t[n+14]}function Ot(n){return n+8}function Gt(n,t){return t[n+6]}function pe(n,t){return t[n+7]}function he(n){return n}let Se,be,le,ve;const Ye=Math.pow(2,32);function ke(n){return"count"in n?1:1+ke(n.left)+ke(n.right)}function ln(n,t,e){return Se=new Float32Array(e),be=new Uint32Array(e),le=new Uint16Array(e),ve=new Uint8Array(e),Oe(n,t)}function Oe(n,t){const e=n/4,s=n/2,i="count"in t,a=t.boundingData;for(let o=0;o<6;o++)Se[e+o]=a[o];if(i)if(t.buffer){const o=t.buffer;ve.set(new Uint8Array(o),n);for(let c=n,r=n+o.byteLength;c<r;c+=Z){const d=c/2;$t(d,le)||(be[c/4+6]+=e)}return n+o.byteLength}else{const o=t.offset,c=t.count;return be[e+6]=o,le[s+14]=c,le[s+15]=$,n+Z}else{const o=t.left,c=t.right,r=t.splitAxis;let d;if(d=Oe(n+Z,o),d/4>Ye)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return be[e+6]=d/4,d=Oe(d,c),be[e+7]=r,d}}function un(n,t){const e=(n.index?n.index.count:n.attributes.position.count)/3,s=e>kn(2,16),i=s?4:2,a=t?new SharedArrayBuffer(e*i):new ArrayBuffer(e*i),o=s?new Uint32Array(a):new Uint16Array(a);for(let c=0,r=o.length;c<r;c++)o[c]=c;return o}function Ke(n,t,e,s,i){const{maxDepth:a,verbose:o,maxLeafTris:c,strategy:r,onProgress:d,indirect:l}=i,p=n._indirectBuffer,f=n.geometry,y=f.index?f.index.array:null,B=l?Fe:Ne,L=Y(f),I=new Float32Array(6);let A=!1;const m=new de;return It(t,e,s,m.boundingData,I),T(m,e,s,I),m;function w(b){d&&d(b/L)}function T(b,E,S,C=null,F=0){if(!A&&F>=a&&(A=!0,o&&(console.warn(`MeshBVH: Max depth of ${a} reached when generating BVH. Consider increasing maxDepth.`),console.warn(f))),S<=c||F>=a)return w(E+S),b.offset=E,b.count=S,b;const k=Wt(b.boundingData,C,t,E,S,r);if(k.axis===-1)return w(E+S),b.offset=E,b.count=S,b;const W=B(p,y,t,E,S,k);if(W===E||W===E+S)w(E+S),b.offset=E,b.count=S;else{b.splitAxis=k.axis;const U=new de,H=E,Q=W-E;b.left=U,It(t,H,Q,U.boundingData,I),T(U,H,Q,I,F+1);const ht=new de,Et=W,Te=S-Q;b.right=ht,It(t,Et,Te,ht.boundingData,I),T(ht,Et,Te,I,F+1)}return b}}function Ge(n,t){const e=n.geometry;t.indirect&&(n._indirectBuffer=un(e,t.useSharedArrayBuffer),Pt(e)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),n._indirectBuffer||st(e,t);const s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=Vt(e),a=t.indirect?tt(e):it(e);n._roots=a.map(o=>{const c=Ke(n,i,o.offset,o.count,t),r=ke(c),d=new s(Z*r);return ln(0,c,d),d})}var ue=nt(88131),ye=nt(39714),Je=nt(14928);class Xt{constructor(t,e,s){this.isOrientedBox=!0,this.min=new h.Vector3,this.max=new h.Vector3,this.matrix=new h.Matrix4,this.invMatrix=new h.Matrix4,this.points=new Array(8).fill().map(()=>new h.Vector3),this.satAxes=new Array(3).fill().map(()=>new h.Vector3),this.satBounds=new Array(3).fill().map(()=>new ue.B),this.alignedSatBounds=new Array(3).fill().map(()=>new ue.B),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),s&&this.matrix.copy(s)}set(t,e,s){this.min.copy(t),this.max.copy(e),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}Xt.prototype.update=function(){return function(){const t=this.matrix,e=this.min,s=this.max,i=this.points;for(let d=0;d<=1;d++)for(let l=0;l<=1;l++)for(let p=0;p<=1;p++){const f=1*d|2*l|4*p,y=i[f];y.x=d?s.x:e.x,y.y=l?s.y:e.y,y.z=p?s.z:e.z,y.applyMatrix4(t)}const a=this.satBounds,o=this.satAxes,c=i[0];for(let d=0;d<3;d++){const l=o[d],p=a[d],f=1<<d,y=i[f];l.subVectors(c,y),p.setFromPoints(l,i)}const r=this.alignedSatBounds;r[0].setFromPointsField(i,"x"),r[1].setFromPointsField(i,"y"),r[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}(),Xt.prototype.intersectsBox=function(){const n=new ue.B;return function(e){this.needsUpdate&&this.update();const s=e.min,i=e.max,a=this.satBounds,o=this.satAxes,c=this.alignedSatBounds;if(n.min=s.x,n.max=i.x,c[0].isSeparated(n)||(n.min=s.y,n.max=i.y,c[1].isSeparated(n))||(n.min=s.z,n.max=i.z,c[2].isSeparated(n)))return!1;for(let r=0;r<3;r++){const d=o[r],l=a[r];if(n.setFromBox(d,e),l.isSeparated(n))return!1}return!0}}(),Xt.prototype.intersectsTriangle=function(){const n=new ye.h,t=new Array(3),e=new ue.B,s=new ue.B,i=new h.Vector3;return function(o){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(n.copy(o),n.update(),o=n);const c=this.satBounds,r=this.satAxes;t[0]=o.a,t[1]=o.b,t[2]=o.c;for(let f=0;f<3;f++){const y=c[f],B=r[f];if(e.setFromPoints(B,t),y.isSeparated(e))return!1}const d=o.satBounds,l=o.satAxes,p=this.points;for(let f=0;f<3;f++){const y=d[f],B=l[f];if(e.setFromPoints(B,p),y.isSeparated(e))return!1}for(let f=0;f<3;f++){const y=r[f];for(let B=0;B<4;B++){const L=l[B];if(i.crossVectors(y,L),e.setFromPoints(i,t),s.setFromPoints(i,p),e.isSeparated(s))return!1}}return!0}}(),Xt.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}(),Xt.prototype.distanceToPoint=function(){const n=new h.Vector3;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}(),Xt.prototype.distanceToBox=function(){const n=["x","y","z"],t=new Array(12).fill().map(()=>new h.Line3),e=new Array(12).fill().map(()=>new h.Line3),s=new h.Vector3,i=new h.Vector3;return function(o,c=0,r=null,d=null){if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(r||d)&&(o.getCenter(i),this.closestPointToPoint(i,s),o.closestPointToPoint(s,i),r&&r.copy(s),d&&d.copy(i)),0;const l=c*c,p=o.min,f=o.max,y=this.points;let B=1/0;for(let I=0;I<8;I++){const A=y[I];i.copy(A).clamp(p,f);const m=A.distanceToSquared(i);if(m<B&&(B=m,r&&r.copy(A),d&&d.copy(i),m<l))return Math.sqrt(m)}let L=0;for(let I=0;I<3;I++)for(let A=0;A<=1;A++)for(let m=0;m<=1;m++){const w=(I+1)%3,T=(I+2)%3,b=A<<w|m<<T,E=1<<I|A<<w|m<<T,S=y[b],C=y[E];t[L].set(S,C);const k=n[I],W=n[w],U=n[T],H=e[L],Q=H.start,ht=H.end;Q[k]=p[k],Q[W]=A?p[W]:f[W],Q[U]=m?p[U]:f[W],ht[k]=f[k],ht[W]=A?p[W]:f[W],ht[U]=m?p[U]:f[W],L++}for(let I=0;I<=1;I++)for(let A=0;A<=1;A++)for(let m=0;m<=1;m++){i.x=I?f.x:p.x,i.y=A?f.y:p.y,i.z=m?f.z:p.z,this.closestPointToPoint(i,s);const w=i.distanceToSquared(s);if(w<B&&(B=w,r&&r.copy(s),d&&d.copy(i),w<l))return Math.sqrt(w)}for(let I=0;I<12;I++){const A=t[I];for(let m=0;m<12;m++){const w=e[m];(0,Je.UX)(A,w,s,i);const T=s.distanceToSquared(i);if(T<B&&(B=T,r&&r.copy(s),d&&d.copy(i),T<l))return Math.sqrt(T)}}return Math.sqrt(B)}}();class ne{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class Pe extends ne{constructor(){super(()=>new ye.h)}}const Ut=new Pe;class Ie{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=s=>{e&&t.push(e),e=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const lt=new Ie;let te,Nt;const Jt=[],Me=new ne(()=>new h.Box3);function fn(n,t,e,s,i,a){te=Me.getPrimitive(),Nt=Me.getPrimitive(),Jt.push(te,Nt),lt.setBuffer(n._roots[t]);const o=Ee(0,n.geometry,e,s,i,a);lt.clearBuffer(),Me.releasePrimitive(te),Me.releasePrimitive(Nt),Jt.pop(),Jt.pop();const c=Jt.length;return c>0&&(Nt=Jt[c-1],te=Jt[c-2]),o}function Ee(n,t,e,s,i=null,a=0,o=0){const{float32Array:c,uint16Array:r,uint32Array:d}=lt;let l=n*2;if($t(l,r)){const f=Mt(n,d),y=Lt(l,r);return J(n,c,te),s(f,y,!1,o,a+n,te)}else{let k=function(U){const{uint16Array:H,uint32Array:Q}=lt;let ht=U*2;for(;!$t(ht,H);)U=Ot(U),ht=U*2;return Mt(U,Q)},W=function(U){const{uint16Array:H,uint32Array:Q}=lt;let ht=U*2;for(;!$t(ht,H);)U=Gt(U,Q),ht=U*2;return Mt(U,Q)+Lt(ht,H)};const f=Ot(n),y=Gt(n,d);let B=f,L=y,I,A,m,w;if(i&&(m=te,w=Nt,J(B,c,m),J(L,c,w),I=i(m),A=i(w),A<I)){B=y,L=f;const U=I;I=A,A=U,m=w}m||(m=te,J(B,c,m));const T=$t(B*2,r),b=e(m,T,I,o+1,a+B);let E;if(b===v){const U=k(B),Q=W(B)-U;E=s(U,Q,!0,o+1,a+B,m)}else E=b&&Ee(B,t,e,s,i,a,o+1);if(E)return!0;w=Nt,J(L,c,w);const S=$t(L*2,r),C=e(w,S,A,o+1,a+L);let F;if(C===v){const U=k(L),Q=W(L)-U;F=s(U,Q,!0,o+1,a+L,w)}else F=C&&Ee(L,t,e,s,i,a,o+1);return!!F}}const ge=new h.Vector3,Ve=new h.Vector3;function dn(n,t,e={},s=0,i=1/0){const a=s*s,o=i*i;let c=1/0,r=null;if(n.shapecast({boundsTraverseOrder:l=>(ge.copy(t).clamp(l.min,l.max),ge.distanceToSquared(t)),intersectsBounds:(l,p,f)=>f<c&&f<o,intersectsTriangle:(l,p)=>{l.closestPointToPoint(t,ge);const f=t.distanceToSquared(ge);return f<c&&(Ve.copy(ge),c=f,r=p),f<a}}),c===1/0)return null;const d=Math.sqrt(c);return e.point?e.point.copy(Ve):e.point=Ve.clone(),e.distance=d,e.faceIndex=r,e}const me=new h.Vector3,xe=new h.Vector3,fe=new h.Vector3,Ce=new h.Vector2,P=new h.Vector2,u=new h.Vector2,g=new h.Vector3,x=new h.Vector3,M=new h.Vector3,_=new h.Vector3;function G(n,t,e,s,i,a){let o;return a===h.BackSide?o=n.intersectTriangle(s,e,t,!0,i):o=n.intersectTriangle(t,e,s,a!==h.DoubleSide,i),o===null?null:{distance:n.origin.distanceTo(i),point:i.clone()}}function V(n,t,e,s,i,a,o,c,r){me.fromBufferAttribute(t,a),xe.fromBufferAttribute(t,o),fe.fromBufferAttribute(t,c);const d=G(n,me,xe,fe,_,r);if(d){s&&(Ce.fromBufferAttribute(s,a),P.fromBufferAttribute(s,o),u.fromBufferAttribute(s,c),d.uv=h.Triangle.getInterpolation(_,me,xe,fe,Ce,P,u,new h.Vector2)),i&&(Ce.fromBufferAttribute(i,a),P.fromBufferAttribute(i,o),u.fromBufferAttribute(i,c),d.uv1=h.Triangle.getInterpolation(_,me,xe,fe,Ce,P,u,new h.Vector2)),e&&(g.fromBufferAttribute(e,a),x.fromBufferAttribute(e,o),M.fromBufferAttribute(e,c),d.normal=h.Triangle.getInterpolation(_,me,xe,fe,g,x,M,new h.Vector3),d.normal.dot(n.direction)>0&&d.normal.multiplyScalar(-1));const l={a,b:o,c,normal:new h.Vector3,materialIndex:0};h.Triangle.getNormal(me,xe,fe,l.normal),d.face=l,d.faceIndex=a}return d}function R(n,t,e,s,i){const a=s*3;let o=a+0,c=a+1,r=a+2;const d=n.index;n.index&&(o=d.getX(o),c=d.getX(c),r=d.getX(r));const{position:l,normal:p,uv:f,uv1:y}=n.attributes,B=V(e,l,p,f,y,o,c,r,t);return B?(B.faceIndex=s,i&&i.push(B),B):null}function z(n,t,e,s){const i=n.a,a=n.b,o=n.c;let c=t,r=t+1,d=t+2;e&&(c=e.getX(c),r=e.getX(r),d=e.getX(d)),i.x=s.getX(c),i.y=s.getY(c),i.z=s.getZ(c),a.x=s.getX(r),a.y=s.getY(r),a.z=s.getZ(r),o.x=s.getX(d),o.y=s.getY(d),o.z=s.getZ(d)}const q=new h.Vector3,rt=new h.Vector3,ct=new h.Vector3,at=new h.Vector2,gt=new h.Vector2,bt=new h.Vector2;function mt(n,t,e,s){const i=t.getIndex().array,a=t.getAttribute("position"),o=t.getAttribute("uv"),c=i[e*3],r=i[e*3+1],d=i[e*3+2];q.fromBufferAttribute(a,c),rt.fromBufferAttribute(a,r),ct.fromBufferAttribute(a,d);let l=0;const p=t.groups,f=e*3;for(let B=0,L=p.length;B<L;B++){const I=p[B],{start:A,count:m}=I;if(f>=A&&f<A+m){l=I.materialIndex;break}}let y=null;return o&&(at.fromBufferAttribute(o,c),gt.fromBufferAttribute(o,r),bt.fromBufferAttribute(o,d),s&&s.uv?y=s.uv:y=new Vector2,Triangle.getInterpolation(n,q,rt,ct,at,gt,bt,y)),s?(s.face||(s.face={}),s.face.a=c,s.face.b=r,s.face.c=d,s.face.materialIndex=l,s.face.normal||(s.face.normal=new Vector3),Triangle.getNormal(q,rt,ct,s.face.normal),y&&(s.uv=y),s):{face:{a:c,b:r,c:d,materialIndex:l,normal:Triangle.getNormal(q,rt,ct,new Vector3)},uv:y}}function K(n,t,e,s,i,a){const{geometry:o,_indirectBuffer:c}=n;for(let r=s,d=s+i;r<d;r++)R(o,t,e,r,a)}function ft(n,t,e,s,i){const{geometry:a,_indirectBuffer:o}=n;let c=1/0,r=null;for(let d=s,l=s+i;d<l;d++){let p;p=R(a,t,e,d),p&&p.distance<c&&(r=p,c=p.distance)}return r}function et(n,t,e,s,i,a,o){const{geometry:c}=e,{index:r}=c,d=c.attributes.position;for(let l=n,p=t+n;l<p;l++){let f;if(f=l,z(o,f*3,r,d),o.needsUpdate=!0,s(o,f,i,a))return!0}return!1}function Bt(n,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=n.geometry,s=e.index?e.index.array:null,i=e.attributes.position;let a,o,c,r,d=0;const l=n._roots;for(let f=0,y=l.length;f<y;f++)a=l[f],o=new Uint32Array(a),c=new Uint16Array(a),r=new Float32Array(a),p(0,d),d+=a.byteLength;function p(f,y,B=!1){const L=f*2;if(c[L+15]===$){const A=o[f+6],m=c[L+14];let w=1/0,T=1/0,b=1/0,E=-1/0,S=-1/0,C=-1/0;for(let F=3*A,k=3*(A+m);F<k;F++){let W=s[F];const U=i.getX(W),H=i.getY(W),Q=i.getZ(W);U<w&&(w=U),U>E&&(E=U),H<T&&(T=H),H>S&&(S=H),Q<b&&(b=Q),Q>C&&(C=Q)}return r[f+0]!==w||r[f+1]!==T||r[f+2]!==b||r[f+3]!==E||r[f+4]!==S||r[f+5]!==C?(r[f+0]=w,r[f+1]=T,r[f+2]=b,r[f+3]=E,r[f+4]=S,r[f+5]=C,!0):!1}else{const A=f+8,m=o[f+6],w=A+y,T=m+y;let b=B,E=!1,S=!1;t?b||(E=t.has(w),S=t.has(T),b=!E&&!S):(E=!0,S=!0);const C=b||E,F=b||S;let k=!1;C&&(k=p(A,y,b));let W=!1;F&&(W=p(m,y,b));const U=k||W;if(U)for(let H=0;H<3;H++){const Q=A+H,ht=m+H,Et=r[Q],Te=r[Q+3],qe=r[ht],Ze=r[ht+3];r[f+H]=Et<qe?Et:qe,r[f+H+3]=Te>Ze?Te:Ze}return U}}}const wt=new h.Box3;function Ft(n,t,e,s){return J(n,t,wt),e.intersectBox(wt,s)}const Yt=new h.Vector3;function qt(n,t,e,s,i){lt.setBuffer(n._roots[t]),Ht(0,n,e,s,i),lt.clearBuffer()}function Ht(n,t,e,s,i){const{float32Array:a,uint16Array:o,uint32Array:c}=lt,r=n*2;if($t(r,o)){const l=Mt(n,c),p=Lt(r,o);K(t,e,s,l,p,i)}else{const l=Ot(n);Ft(l,a,s,Yt)&&Ht(l,t,e,s,i);const p=Gt(n,c);Ft(p,a,s,Yt)&&Ht(p,t,e,s,i)}}const Ae=new h.Vector3,se=["x","y","z"];function _e(n,t,e,s){lt.setBuffer(n._roots[t]);const i=vt(0,n,e,s);return lt.clearBuffer(),i}function vt(n,t,e,s){const{float32Array:i,uint16Array:a,uint32Array:o}=lt;let c=n*2;if($t(c,a)){const d=Mt(n,o),l=Lt(c,a);return ft(t,e,s,d,l)}else{const d=pe(n,o),l=se[d],f=s.direction[l]>=0;let y,B;f?(y=Ot(n),B=Gt(n,o)):(y=Gt(n,o),B=Ot(n));const I=Ft(y,i,s,Ae)?vt(y,t,e,s):null;if(I){const w=I.point[l];if(f?w<=i[B+d]:w>=i[B+d+3])return I}const m=Ft(B,i,s,Ae)?vt(B,t,e,s):null;return I&&m?I.distance<=m.distance?I:m:I||m||null}}const ce=new h.Box3,zt=new ye.h,Qt=new ye.h,ie=new h.Matrix4,pn=new Xt,Le=new Xt;function On(n,t,e,s){lt.setBuffer(n._roots[t]);const i=hn(0,n,e,s);return lt.clearBuffer(),i}function hn(n,t,e,s,i=null){const{float32Array:a,uint16Array:o,uint32Array:c}=lt;let r=n*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),pn.set(e.boundingBox.min,e.boundingBox.max,s),i=pn),$t(r,o)){const l=t.geometry,p=l.index,f=l.attributes.position,y=e.index,B=e.attributes.position,L=Mt(n,c),I=Lt(r,o);if(ie.copy(s).invert(),e.boundsTree)return J(n,a,Le),Le.matrix.copy(ie),Le.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:m=>Le.intersectsBox(m),intersectsTriangle:m=>{m.a.applyMatrix4(s),m.b.applyMatrix4(s),m.c.applyMatrix4(s),m.needsUpdate=!0;for(let w=L*3,T=(I+L)*3;w<T;w+=3)if(z(Qt,w,p,f),Qt.needsUpdate=!0,m.intersectsTriangle(Qt))return!0;return!1}});for(let A=L*3,m=(I+L)*3;A<m;A+=3){z(zt,A,p,f),zt.a.applyMatrix4(ie),zt.b.applyMatrix4(ie),zt.c.applyMatrix4(ie),zt.needsUpdate=!0;for(let w=0,T=y.count;w<T;w+=3)if(z(Qt,w,y,B),Qt.needsUpdate=!0,zt.intersectsTriangle(Qt))return!0}}else{const l=n+8,p=c[n+6];return J(l,a,ce),!!(i.intersectsBox(ce)&&hn(l,t,e,s,i)||(J(p,a,ce),i.intersectsBox(ce)&&hn(p,t,e,s,i)))}}const Qe=new h.Matrix4,yn=new Xt,Xe=new Xt,Gn=new h.Vector3,Xn=new h.Vector3,Hn=new h.Vector3,jn=new h.Vector3;function Wn(n,t,e,s={},i={},a=0,o=1/0){t.boundingBox||t.computeBoundingBox(),yn.set(t.boundingBox.min,t.boundingBox.max,e),yn.needsUpdate=!0;const c=n.geometry,r=c.attributes.position,d=c.index,l=t.attributes.position,p=t.index,f=Ut.getPrimitive(),y=Ut.getPrimitive();let B=Gn,L=Xn,I=null,A=null;i&&(I=Hn,A=jn);let m=1/0,w=null,T=null;return Qe.copy(e).invert(),Xe.matrix.copy(Qe),n.shapecast({boundsTraverseOrder:b=>yn.distanceToBox(b),intersectsBounds:(b,E,S)=>S<m&&S<o?(E&&(Xe.min.copy(b.min),Xe.max.copy(b.max),Xe.needsUpdate=!0),!0):!1,intersectsRange:(b,E)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:C=>Xe.distanceToBox(C),intersectsBounds:(C,F,k)=>k<m&&k<o,intersectsRange:(C,F)=>{for(let k=C,W=C+F;k<W;k++){z(y,3*k,p,l),y.a.applyMatrix4(e),y.b.applyMatrix4(e),y.c.applyMatrix4(e),y.needsUpdate=!0;for(let U=b,H=b+E;U<H;U++){z(f,3*U,d,r),f.needsUpdate=!0;const Q=f.distanceToTriangle(y,B,I);if(Q<m&&(L.copy(B),A&&A.copy(I),m=Q,w=U,T=k),Q<a)return!0}}}});{const S=Y(t);for(let C=0,F=S;C<F;C++){z(y,3*C,p,l),y.a.applyMatrix4(e),y.b.applyMatrix4(e),y.c.applyMatrix4(e),y.needsUpdate=!0;for(let k=b,W=b+E;k<W;k++){z(f,3*k,d,r),f.needsUpdate=!0;const U=f.distanceToTriangle(y,B,I);if(U<m&&(L.copy(B),A&&A.copy(I),m=U,w=k,T=C),U<a)return!0}}}}}),Ut.releasePrimitive(f),Ut.releasePrimitive(y),m===1/0?null:(s.point?s.point.copy(L):s.point=L.clone(),s.distance=m,s.faceIndex=w,i&&(i.point?i.point.copy(A):i.point=A.clone(),i.point.applyMatrix4(Qe),L.applyMatrix4(Qe),i.distance=L.sub(i.point).length(),i.faceIndex=T),s)}function $n(n,t,e,s,i,a){const{geometry:o,_indirectBuffer:c}=n;for(let r=s,d=s+i;r<d;r++){let l=c?c[r]:r;R(o,t,e,l,a)}}function qn(n,t,e,s,i){const{geometry:a,_indirectBuffer:o}=n;let c=1/0,r=null;for(let d=s,l=s+i;d<l;d++){let p;p=R(a,t,e,o?o[d]:d),p&&p.distance<c&&(r=p,c=p.distance)}return r}function Zn(n,t,e,s,i,a,o){const{geometry:c}=e,{index:r}=c,d=c.attributes.position;for(let l=n,p=t+n;l<p;l++){let f;if(f=e.resolveTriangleIndex(l),z(o,f*3,r,d),o.needsUpdate=!0,s(o,f,i,a))return!0}return!1}function Yn(n,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=n.geometry,s=e.index?e.index.array:null,i=e.attributes.position;let a,o,c,r,d=0;const l=n._roots;for(let f=0,y=l.length;f<y;f++)a=l[f],o=new Uint32Array(a),c=new Uint16Array(a),r=new Float32Array(a),p(0,d),d+=a.byteLength;function p(f,y,B=!1){const L=f*2;if(c[L+15]===$){const A=o[f+6],m=c[L+14];let w=1/0,T=1/0,b=1/0,E=-1/0,S=-1/0,C=-1/0;for(let F=A,k=A+m;F<k;F++){const W=3*n.resolveTriangleIndex(F);for(let U=0;U<3;U++){let H=W+U;H=s?s[H]:H;const Q=i.getX(H),ht=i.getY(H),Et=i.getZ(H);Q<w&&(w=Q),Q>E&&(E=Q),ht<T&&(T=ht),ht>S&&(S=ht),Et<b&&(b=Et),Et>C&&(C=Et)}}return r[f+0]!==w||r[f+1]!==T||r[f+2]!==b||r[f+3]!==E||r[f+4]!==S||r[f+5]!==C?(r[f+0]=w,r[f+1]=T,r[f+2]=b,r[f+3]=E,r[f+4]=S,r[f+5]=C,!0):!1}else{const A=f+8,m=o[f+6],w=A+y,T=m+y;let b=B,E=!1,S=!1;t?b||(E=t.has(w),S=t.has(T),b=!E&&!S):(E=!0,S=!0);const C=b||E,F=b||S;let k=!1;C&&(k=p(A,y,b));let W=!1;F&&(W=p(m,y,b));const U=k||W;if(U)for(let H=0;H<3;H++){const Q=A+H,ht=m+H,Et=r[Q],Te=r[Q+3],qe=r[ht],Ze=r[ht+3];r[f+H]=Et<qe?Et:qe,r[f+H+3]=Te>Ze?Te:Ze}return U}}}const En=new h.Vector3;function Kn(n,t,e,s,i){lt.setBuffer(n._roots[t]),gn(0,n,e,s,i),lt.clearBuffer()}function gn(n,t,e,s,i){const{float32Array:a,uint16Array:o,uint32Array:c}=lt,r=n*2;if($t(r,o)){const l=Mt(n,c),p=Lt(r,o);$n(t,e,s,l,p,i)}else{const l=Ot(n);Ft(l,a,s,En)&&gn(l,t,e,s,i);const p=Gt(n,c);Ft(p,a,s,En)&&gn(p,t,e,s,i)}}const Vn=new h.Vector3,Jn=["x","y","z"];function Qn(n,t,e,s){lt.setBuffer(n._roots[t]);const i=mn(0,n,e,s);return lt.clearBuffer(),i}function mn(n,t,e,s){const{float32Array:i,uint16Array:a,uint32Array:o}=lt;let c=n*2;if($t(c,a)){const d=Mt(n,o),l=Lt(c,a);return qn(t,e,s,d,l)}else{const d=pe(n,o),l=Jn[d],f=s.direction[l]>=0;let y,B;f?(y=Ot(n),B=Gt(n,o)):(y=Gt(n,o),B=Ot(n));const I=Ft(y,i,s,Vn)?mn(y,t,e,s):null;if(I){const w=I.point[l];if(f?w<=i[B+d]:w>=i[B+d+3])return I}const m=Ft(B,i,s,Vn)?mn(B,t,e,s):null;return I&&m?I.distance<=m.distance?I:m:I||m||null}}const tn=new h.Box3,Ue=new ye.h,ze=new ye.h,He=new h.Matrix4,Cn=new Xt,en=new Xt;function ts(n,t,e,s){lt.setBuffer(n._roots[t]);const i=xn(0,n,e,s);return lt.clearBuffer(),i}function xn(n,t,e,s,i=null){const{float32Array:a,uint16Array:o,uint32Array:c}=lt;let r=n*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),Cn.set(e.boundingBox.min,e.boundingBox.max,s),i=Cn),$t(r,o)){const l=t.geometry,p=l.index,f=l.attributes.position,y=e.index,B=e.attributes.position,L=Mt(n,c),I=Lt(r,o);if(He.copy(s).invert(),e.boundsTree)return J(n,a,en),en.matrix.copy(He),en.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:m=>en.intersectsBox(m),intersectsTriangle:m=>{m.a.applyMatrix4(s),m.b.applyMatrix4(s),m.c.applyMatrix4(s),m.needsUpdate=!0;for(let w=L,T=I+L;w<T;w++)if(z(ze,3*t.resolveTriangleIndex(w),p,f),ze.needsUpdate=!0,m.intersectsTriangle(ze))return!0;return!1}});for(let A=L,m=I+L;A<m;A++){const w=t.resolveTriangleIndex(A);z(Ue,3*w,p,f),Ue.a.applyMatrix4(He),Ue.b.applyMatrix4(He),Ue.c.applyMatrix4(He),Ue.needsUpdate=!0;for(let T=0,b=y.count;T<b;T+=3)if(z(ze,T,y,B),ze.needsUpdate=!0,Ue.intersectsTriangle(ze))return!0}}else{const l=n+8,p=c[n+6];return J(l,a,tn),!!(i.intersectsBox(tn)&&xn(l,t,e,s,i)||(J(p,a,tn),i.intersectsBox(tn)&&xn(p,t,e,s,i)))}}const nn=new h.Matrix4,An=new Xt,je=new Xt,es=new h.Vector3,ns=new h.Vector3,ss=new h.Vector3,is=new h.Vector3;function rs(n,t,e,s={},i={},a=0,o=1/0){t.boundingBox||t.computeBoundingBox(),An.set(t.boundingBox.min,t.boundingBox.max,e),An.needsUpdate=!0;const c=n.geometry,r=c.attributes.position,d=c.index,l=t.attributes.position,p=t.index,f=Ut.getPrimitive(),y=Ut.getPrimitive();let B=es,L=ns,I=null,A=null;i&&(I=ss,A=is);let m=1/0,w=null,T=null;return nn.copy(e).invert(),je.matrix.copy(nn),n.shapecast({boundsTraverseOrder:b=>An.distanceToBox(b),intersectsBounds:(b,E,S)=>S<m&&S<o?(E&&(je.min.copy(b.min),je.max.copy(b.max),je.needsUpdate=!0),!0):!1,intersectsRange:(b,E)=>{if(t.boundsTree){const S=t.boundsTree;return S.shapecast({boundsTraverseOrder:C=>je.distanceToBox(C),intersectsBounds:(C,F,k)=>k<m&&k<o,intersectsRange:(C,F)=>{for(let k=C,W=C+F;k<W;k++){const U=S.resolveTriangleIndex(k);z(y,3*U,p,l),y.a.applyMatrix4(e),y.b.applyMatrix4(e),y.c.applyMatrix4(e),y.needsUpdate=!0;for(let H=b,Q=b+E;H<Q;H++){const ht=n.resolveTriangleIndex(H);z(f,3*ht,d,r),f.needsUpdate=!0;const Et=f.distanceToTriangle(y,B,I);if(Et<m&&(L.copy(B),A&&A.copy(I),m=Et,w=H,T=k),Et<a)return!0}}}})}else{const S=Y(t);for(let C=0,F=S;C<F;C++){z(y,3*C,p,l),y.a.applyMatrix4(e),y.b.applyMatrix4(e),y.c.applyMatrix4(e),y.needsUpdate=!0;for(let k=b,W=b+E;k<W;k++){const U=n.resolveTriangleIndex(k);z(f,3*U,d,r),f.needsUpdate=!0;const H=f.distanceToTriangle(y,B,I);if(H<m&&(L.copy(B),A&&A.copy(I),m=H,w=k,T=C),H<a)return!0}}}}}),Ut.releasePrimitive(f),Ut.releasePrimitive(y),m===1/0?null:(s.point?s.point.copy(L):s.point=L.clone(),s.distance=m,s.faceIndex=w,i&&(i.point?i.point.copy(A):i.point=A.clone(),i.point.applyMatrix4(nn),L.applyMatrix4(nn),i.distance=L.sub(i.point).length(),i.faceIndex=T),s)}function os(){return typeof SharedArrayBuffer!="undefined"}function Vs(n,t){if(n===null)return n;if(n.buffer){const e=n.buffer;if(e.constructor===t)return n;const s=n.constructor,i=new s(new t(e.byteLength));return i.set(n),i}else{if(n.constructor===t)return n;const e=new t(n.byteLength);return new Uint8Array(e).set(new Uint8Array(n)),e}}const We=new lt.constructor,sn=new lt.constructor,we=new ne(()=>new h.Box3),Re=new h.Box3,De=new h.Box3,wn=new h.Box3,Tn=new h.Box3;let bn=!1;function cs(n,t,e,s){if(bn)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");bn=!0;const i=n._roots,a=t._roots;let o,c=0,r=0;const d=new h.Matrix4().copy(e).invert();for(let l=0,p=i.length;l<p;l++){We.setBuffer(i[l]),r=0;const f=we.getPrimitive();J(0,We.float32Array,f),f.applyMatrix4(d);for(let y=0,B=a.length;y<B&&(sn.setBuffer(a[l]),o=re(0,0,e,d,s,c,r,0,0,f),sn.clearBuffer(),r+=a[y].length,!o);y++);if(we.releasePrimitive(f),We.clearBuffer(),c+=i[l].length,o)break}return bn=!1,o}function re(n,t,e,s,i,a=0,o=0,c=0,r=0,d=null,l=!1){let p,f;l?(p=sn,f=We):(p=We,f=sn);const y=p.float32Array,B=p.uint32Array,L=p.uint16Array,I=f.float32Array,A=f.uint32Array,m=f.uint16Array,w=n*2,T=t*2,b=$t(w,L),E=$t(T,m);let S=!1;if(E&&b)l?S=i(Mt(t,A),Lt(t*2,m),Mt(n,B),Lt(n*2,L),r,o+t,c,a+n):S=i(Mt(n,B),Lt(n*2,L),Mt(t,A),Lt(t*2,m),c,a+n,r,o+t);else if(E){const C=we.getPrimitive();J(t,I,C),C.applyMatrix4(e);const F=Ot(n),k=Gt(n,B);J(F,y,Re),J(k,y,De);const W=C.intersectsBox(Re),U=C.intersectsBox(De);S=W&&re(t,F,s,e,i,o,a,r,c+1,C,!l)||U&&re(t,k,s,e,i,o,a,r,c+1,C,!l),we.releasePrimitive(C)}else{const C=Ot(t),F=Gt(t,A);J(C,I,wn),J(F,I,Tn);const k=d.intersectsBox(wn),W=d.intersectsBox(Tn);if(k&&W)S=re(n,C,e,s,i,a,o,c,r+1,d,l)||re(n,F,e,s,i,a,o,c,r+1,d,l);else if(k)if(b)S=re(n,C,e,s,i,a,o,c,r+1,d,l);else{const U=we.getPrimitive();U.copy(wn).applyMatrix4(e);const H=Ot(n),Q=Gt(n,B);J(H,y,Re),J(Q,y,De);const ht=U.intersectsBox(Re),Et=U.intersectsBox(De);S=ht&&re(C,H,s,e,i,o,a,r,c+1,U,!l)||Et&&re(C,Q,s,e,i,o,a,r,c+1,U,!l),we.releasePrimitive(U)}else if(W)if(b)S=re(n,F,e,s,i,a,o,c,r+1,d,l);else{const U=we.getPrimitive();U.copy(Tn).applyMatrix4(e);const H=Ot(n),Q=Gt(n,B);J(H,y,Re),J(Q,y,De);const ht=U.intersectsBox(Re),Et=U.intersectsBox(De);S=ht&&re(F,H,s,e,i,o,a,r,c+1,U,!l)||Et&&re(F,Q,s,e,i,o,a,r,c+1,U,!l),we.releasePrimitive(U)}}return S}const rn=new Xt,Ln=new h.Box3,as={strategy:Dt,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0};class _n{static serialize(t,e={}){e=Be({cloneBuffers:!0},e);const s=t.geometry,i=t._roots,a=t._indirectBuffer,o=s.getIndex();let c;return e.cloneBuffers?c={roots:i.map(r=>r.slice()),index:o.array.slice(),indirectBuffer:a?a.slice():null}:c={roots:i,index:o.array,indirectBuffer:a},c}static deserialize(t,e,s={}){s=Be({setIndex:!0,indirect:!!t.indirectBuffer},s);const{index:i,roots:a,indirectBuffer:o}=t,c=new _n(e,an(Be({},s),{[O]:!0}));if(c._roots=a,c._indirectBuffer=o||null,s.setIndex){const r=e.getIndex();if(r===null){const d=new h.BufferAttribute(t.index,1,!1);e.setIndex(d)}else r.array!==i&&(r.array.set(i),r.needsUpdate=!0)}return c}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign(an(Be({},as),{[O]:!1}),e),e.useSharedArrayBuffer&&!os())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[O]||(Ge(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new h.Box3)));const{_indirectBuffer:s}=this;this.resolveTriangleIndex=e.indirect?i=>s[i]:i=>i}refit(t=null){return(this.indirect?Yn:Bt)(this,t)}traverse(t,e=0){const s=this._roots[e],i=new Uint32Array(s),a=new Uint16Array(s);o(0);function o(c,r=0){const d=c*2,l=a[d+15]===$;if(l){const p=i[c+6],f=a[d+14];t(r,l,new Float32Array(s,c*4,6),p,f)}else{const p=c+Z/4,f=i[c+6],y=i[c+7];t(r,l,new Float32Array(s,c*4,6),y)||(o(p,r+1),o(f,r+1))}}}raycast(t,e=h.FrontSide){const s=this._roots,i=this.geometry,a=[],o=e.isMaterial,c=Array.isArray(e),r=i.groups,d=o?e.side:e,l=this.indirect?Kn:qt;for(let p=0,f=s.length;p<f;p++){const y=c?e[r[p].materialIndex].side:d,B=a.length;if(l(this,p,y,t,a),c){const L=r[p].materialIndex;for(let I=B,A=a.length;I<A;I++)a[I].face.materialIndex=L}}return a}raycastFirst(t,e=h.FrontSide){const s=this._roots,i=this.geometry,a=e.isMaterial,o=Array.isArray(e);let c=null;const r=i.groups,d=a?e.side:e,l=this.indirect?Qn:_e;for(let p=0,f=s.length;p<f;p++){const y=o?e[r[p].materialIndex].side:d,B=l(this,p,y,t);B!=null&&(c==null||B.distance<c.distance)&&(c=B,o&&(B.face.materialIndex=r[p].materialIndex))}return c}intersectsGeometry(t,e){let s=!1;const i=this._roots,a=this.indirect?ts:On;for(let o=0,c=i.length;o<c&&(s=a(this,o,t,e),!s);o++);return s}shapecast(t){const e=Ut.getPrimitive(),s=this.indirect?Zn:et;let{boundsTraverseOrder:i,intersectsBounds:a,intersectsRange:o,intersectsTriangle:c}=t;if(o&&c){const p=o;o=(f,y,B,L,I)=>p(f,y,B,L,I)?!0:s(f,y,this,c,B,L,e)}else o||(c?o=(p,f,y,B)=>s(p,f,this,c,y,B,e):o=(p,f,y)=>y);let r=!1,d=0;const l=this._roots;for(let p=0,f=l.length;p<f;p++){const y=l[p];if(r=fn(this,p,a,o,i,d),r)break;d+=y.byteLength}return Ut.releasePrimitive(e),r}bvhcast(t,e,s){let{intersectsRanges:i,intersectsTriangles:a}=s;const o=Ut.getPrimitive(),c=this.geometry.index,r=this.geometry.attributes.position,d=this.indirect?B=>{const L=this.resolveTriangleIndex(B);z(o,L*3,c,r)}:B=>{z(o,B*3,c,r)},l=Ut.getPrimitive(),p=t.geometry.index,f=t.geometry.attributes.position,y=t.indirect?B=>{const L=t.resolveTriangleIndex(B);z(l,L*3,p,f)}:B=>{z(l,B*3,p,f)};if(a){const B=(L,I,A,m,w,T,b,E)=>{for(let S=A,C=A+m;S<C;S++){y(S),l.a.applyMatrix4(e),l.b.applyMatrix4(e),l.c.applyMatrix4(e),l.needsUpdate=!0;for(let F=L,k=L+I;F<k;F++)if(d(F),o.needsUpdate=!0,a(o,l,F,S,w,T,b,E))return!0}return!1};if(i){const L=i;i=function(I,A,m,w,T,b,E,S){return L(I,A,m,w,T,b,E,S)?!0:B(I,A,m,w,T,b,E,S)}}else i=B}return cs(this,t,e,i)}intersectsBox(t,e){return rn.set(t.min,t.max,e),rn.needsUpdate=!0,this.shapecast({intersectsBounds:s=>rn.intersectsBox(s),intersectsTriangle:s=>rn.intersectsTriangle(s)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,s={},i={},a=0,o=1/0){return(this.indirect?rs:Wn)(this,t,e,s,i,a,o)}closestPointToPoint(t,e={},s=0,i=1/0){return dn(this,t,e,s,i)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(s=>{J(0,new Float32Array(s),Ln),t.union(Ln)}),t}}const Un=1e-6,ls=Un*.5,zn=Math.pow(10,-Math.log10(Un)),us=ls*zn;function ae(n){return~~(n*zn+us)}function fs(n){return`${ae(n.x)},${ae(n.y)}`}function on(n){return`${ae(n.x)},${ae(n.y)},${ae(n.z)}`}function ds(n){return`${ae(n.x)},${ae(n.y)},${ae(n.z)},${ae(n.w)}`}function Cs(n){return`${on(n.origin)}-${on(n.direction)}`}function ps(n,t,e){e.direction.subVectors(t,n).normalize();const s=n.dot(e.direction);return e.origin.copy(n).addScaledVector(e.direction,-s),e}var $e=nt(63284);const hs=1e-8,ys=new h.Vector3;function gs(n){return~~(n/3)}function ms(n){return n%3}function Bn(n,t){return n.start-t.start}function Rn(n,t){return ys.subVectors(t,n.origin).dot(n.direction)}function Ls(n){n=[...n].sort(Bn);for(let t=0,e=n.length;t<e-1;t++){const s=n[t],i=n[t+1];if(i.start<s.end&&Math.abs(i.start-s.end)>1e-5)return!0}return!1}function Us(n){let t=0;return n.forEach(({start:e,end:s})=>t+=s-e),t}function xs(n,t,e,s=hs){n.sort(Bn),t.sort(Bn);for(let c=0;c<n.length;c++){const r=n[c];for(let d=0;d<t.length;d++){const l=t[d];if(!(l.start>r.end)){if(r.end<l.start||l.end<r.start)continue;if(r.start<=l.start&&r.end>=l.end)a(l.end,r.end)||n.splice(c+1,0,{start:l.end,end:r.end,index:r.index}),r.end=l.start,l.start=0,l.end=0;else if(r.start>=l.start&&r.end<=l.end)a(r.end,l.end)||t.splice(d+1,0,{start:r.end,end:l.end,index:l.index}),l.end=r.start,r.start=0,r.end=0;else if(r.start<=l.start&&r.end<=l.end){const p=r.end;r.end=l.start,l.start=p}else if(r.start>=l.start&&r.end>=l.end){const p=l.end;l.end=r.start,r.start=p}else throw new Error}if(e.has(r.index)||e.set(r.index,[]),e.has(l.index)||e.set(l.index,[]),e.get(r.index).push(l.index),e.get(l.index).push(r.index),o(l)&&(t.splice(d,1),d--),o(r)){n.splice(c,1),c--;break}}}i(n),i(t);function i(c){for(let r=0;r<c.length;r++)o(c[r])&&(c.splice(r,1),r--)}function a(c,r){return Math.abs(r-c)<s}function o(c){return Math.abs(c.end-c.start)<s}}const Dn=1e-5,Nn=1e-4;class As{constructor(){this._rays=[]}addRay(t){this._rays.push(t)}findClosestRay(t){const e=this._rays,s=t.clone();s.direction.multiplyScalar(-1);let i=1/0,a=null;for(let r=0,d=e.length;r<d;r++){const l=e[r];if(o(l,t)&&o(l,s))continue;const p=c(l,t),f=c(l,s),y=Math.min(p,f);y<i&&(i=y,a=l)}return a;function o(r,d){const l=r.origin.distanceTo(d.origin)>Dn;return r.direction.angleTo(d.direction)>Nn||l}function c(r,d){const l=r.origin.distanceTo(d.origin),p=r.direction.angleTo(d.direction);return l/Dn+p/Nn}}}const Sn=new h.Vector3,Pn=new h.Vector3,cn=new h.Ray;function ws(n,t,e){const s=n.attributes,i=n.index,a=s.position,o=new Map,c=new Map,r=Array.from(t),d=new As;for(let l=0,p=r.length;l<p;l++){const f=r[l],y=gs(f),B=ms(f);let L=3*y+B,I=3*y+(B+1)%3;i&&(L=i.getX(L),I=i.getX(I)),Sn.fromBufferAttribute(a,L),Pn.fromBufferAttribute(a,I),ps(Sn,Pn,cn);let A,m=d.findClosestRay(cn);m===null&&(m=cn.clone(),d.addRay(m)),c.has(m)||c.set(m,{forward:[],reverse:[],ray:m}),A=c.get(m);let w=Rn(m,Sn),T=Rn(m,Pn);w>T&&([w,T]=[T,w]),cn.direction.dot(m.direction)<0?A.reverse.push({start:w,end:T,index:f}):A.forward.push({start:w,end:T,index:f})}return c.forEach(({forward:l,reverse:p},f)=>{xs(l,p,o,e),l.length===0&&p.length===0&&c.delete(f)}),{disjointConnectivityMap:o,fragmentMap:c}}const Ts=new h.Vector2,In=new h.Vector3,bs=new h.Vector4,Mn=["","",""];class _s{constructor(t=null){this.data=null,this.disjointConnections=null,this.unmatchedDisjointEdges=null,this.unmatchedEdges=-1,this.matchedEdges=-1,this.useDrawRange=!0,this.useAllAttributes=!1,this.matchDisjointEdges=!1,this.degenerateEpsilon=1e-8,t&&this.updateFrom(t)}getSiblingTriangleIndex(t,e){const s=this.data[t*3+e];return s===-1?-1:~~(s/3)}getSiblingEdgeIndex(t,e){const s=this.data[t*3+e];return s===-1?-1:s%3}getDisjointSiblingTriangleIndices(t,e){const s=t*3+e,i=this.disjointConnections.get(s);return i?i.map(a=>~~(a/3)):[]}getDisjointSiblingEdgeIndices(t,e){const s=t*3+e,i=this.disjointConnections.get(s);return i?i.map(a=>a%3):[]}isFullyConnected(){return this.unmatchedEdges===0}updateFrom(t){const{useAllAttributes:e,useDrawRange:s,matchDisjointEdges:i,degenerateEpsilon:a}=this,o=e?w:m,c=new Map,{attributes:r}=t,d=e?Object.keys(r):null,l=t.index,p=r.position;let f=(0,$e.YU)(t);const y=f;let B=0;s&&(B=t.drawRange.start,t.drawRange.count!==1/0&&(f=~~(t.drawRange.count/3)));let L=this.data;(!L||L.length<3*y)&&(L=new Int32Array(3*y)),L.fill(-1);let I=0,A=new Set;for(let T=B,b=f*3+B;T<b;T+=3){const E=T;for(let S=0;S<3;S++){let C=E+S;l&&(C=l.getX(C)),Mn[S]=o(C)}for(let S=0;S<3;S++){const C=(S+1)%3,F=Mn[S],k=Mn[C],W=`${k}_${F}`;if(c.has(W)){const U=E+S,H=c.get(W);L[U]=H,L[H]=U,c.delete(W),I+=2,A.delete(H)}else{const U=`${F}_${k}`,H=E+S;c.set(U,H),A.add(H)}}}if(i){const{fragmentMap:T,disjointConnectivityMap:b}=ws(t,A,a);A.clear(),T.forEach(({forward:E,reverse:S})=>{E.forEach(({index:C})=>A.add(C)),S.forEach(({index:C})=>A.add(C))}),this.unmatchedDisjointEdges=T,this.disjointConnections=b,I=f*3-A.size}this.matchedEdges=I,this.unmatchedEdges=A.size,this.data=L;function m(T){return In.fromBufferAttribute(p,T),on(In)}function w(T){let b="";for(let E=0,S=d.length;E<S;E++){const C=r[d[E]];let F;switch(C.itemSize){case 1:F=ae(C.getX(T));break;case 2:F=fs(Ts.fromBufferAttribute(C,T));break;case 3:F=on(In.fromBufferAttribute(C,T));break;case 4:F=ds(bs.fromBufferAttribute(C,T));break}b!==""&&(b+="|"),b+=F}return b}}}class Bs extends h.Mesh{constructor(...t){super(...t),this.isBrush=!0,this._previousMatrix=new h.Matrix4,this._previousMatrix.elements.fill(0)}markUpdated(){this._previousMatrix.copy(this.matrix)}isDirty(){const{matrix:t,_previousMatrix:e}=this,s=t.elements,i=e.elements;for(let a=0;a<16;a++)if(s[a]!==i[a])return!0;return!1}prepareGeometry(){const t=this.geometry,e=t.attributes,s=(0,$e.EC)();if(s)for(const i in e){const a=e[i];if(a.isInterleavedBufferAttribute)throw new Error("Brush: InterleavedBufferAttributes are not supported.");a.array=(0,$e.ik)(a.array)}if(t.boundsTree||((0,$e.BB)(t,{useSharedArrayBuffer:s}),t.boundsTree=new _n(t,{maxLeafTris:3,indirect:!0,useSharedArrayBuffer:s})),t.halfEdges||(t.halfEdges=new _s(t)),!t.groupIndices){const i=(0,$e.YU)(t),a=new Uint16Array(i),o=t.groups;for(let c=0,r=o.length;c<r;c++){const{start:d,count:l}=o[c];for(let p=d/3,f=(d+l)/3;p<f;p++)a[p]=c}t.groupIndices=a}}disposeCacheData(){const{geometry:t}=this;t.halfEdges=null,t.boundsTree=null,t.groupIndices=null}}},15539:function(jt,Tt,nt){nt.d(Tt,{v:function(){return Ce}});var h=nt(99477),Dt=nt(39714);const Kt=1e-14,St=new h.Vector3,dt=new h.Vector3,ut=new h.Vector3;function v(P,u=Kt){St.subVectors(P.b,P.a),dt.subVectors(P.c,P.a),ut.subVectors(P.b,P.c);const g=St.angleTo(dt),x=St.angleTo(ut),M=Math.PI-g-x;return Math.abs(g)<u||Math.abs(x)<u||Math.abs(M)<u||P.a.distanceToSquared(P.b)<u||P.a.distanceToSquared(P.c)<u||P.b.distanceToSquared(P.c)<u}const D=1e-10,X=1e-10,Z=1e-10,$=new h.Line3,N=new h.Line3,O=new h.Vector3,j=new h.Vector3,Y=new h.Vector3,ot=new h.Plane,st=new Dt.h;class tt{constructor(){this._pool=[],this._index=0}getTriangle(){return this._index>=this._pool.length&&this._pool.push(new h.Triangle),this._pool[this._index++]}clear(){this._index=0}reset(){this._pool.length=0,this._index=0}}class it{constructor(){this.trianglePool=new tt,this.triangles=[],this.normal=new h.Vector3,this.coplanarTriangleUsed=!1}initialize(u){this.reset();const{triangles:g,trianglePool:x,normal:M}=this;if(Array.isArray(u))for(let _=0,G=u.length;_<G;_++){const V=u[_];if(_===0)V.getNormal(M);else if(Math.abs(1-V.getNormal(O).dot(M))>D)throw new Error("Triangle Splitter: Cannot initialize with triangles that have different normals.");const R=x.getTriangle();R.copy(V),g.push(R)}else{u.getNormal(M);const _=x.getTriangle();_.copy(u),g.push(_)}}splitByTriangle(u){const{normal:g,triangles:x}=this;if(u.getNormal(j).normalize(),Math.abs(1-Math.abs(j.dot(g)))<Z){this.coplanarTriangleUsed=!0;for(let _=0,G=x.length;_<G;_++){const V=x[_];V.coplanarCount=0}const M=[u.a,u.b,u.c];for(let _=0;_<3;_++){const G=(_+1)%3,V=M[_],R=M[G];O.subVectors(R,V).normalize(),Y.crossVectors(j,O),ot.setFromNormalAndCoplanarPoint(Y,V),this.splitByPlane(ot,u)}}else u.getPlane(ot),this.splitByPlane(ot,u)}splitByPlane(u,g){const{triangles:x,trianglePool:M}=this;st.copy(g),st.needsUpdate=!0;for(let _=0,G=x.length;_<G;_++){const V=x[_];if(!st.intersectsTriangle(V,$,!0))continue;const{a:R,b:z,c:q}=V;let rt=0,ct=-1,at=!1,gt=[],bt=[];const mt=[R,z,q];for(let K=0;K<3;K++){const ft=(K+1)%3;$.start.copy(mt[K]),$.end.copy(mt[ft]);const et=u.distanceToPoint($.start),Bt=u.distanceToPoint($.end);if(Math.abs(et)<X&&Math.abs(Bt)<X){at=!0;break}if(et>0?gt.push(K):bt.push(K),Math.abs(et)<X)continue;let wt=!!u.intersectLine($,O);!wt&&Math.abs(Bt)<X&&(O.copy($.end),wt=!0),wt&&!(O.distanceTo($.start)<D)&&(O.distanceTo($.end)<D&&(ct=K),rt===0?N.start.copy(O):N.end.copy(O),rt++)}if(!at&&rt===2&&N.distance()>X)if(ct!==-1){ct=(ct+1)%3;let K=0;K===ct&&(K=(K+1)%3);let ft=K+1;ft===ct&&(ft=(ft+1)%3);const et=M.getTriangle();et.a.copy(mt[ft]),et.b.copy(N.end),et.c.copy(N.start),v(et)||x.push(et),V.a.copy(mt[K]),V.b.copy(N.start),V.c.copy(N.end),v(V)&&(x.splice(_,1),_--,G--)}else{const K=gt.length>=2?bt[0]:gt[0];if(K===0){let Ft=N.start;N.start=N.end,N.end=Ft}const ft=(K+1)%3,et=(K+2)%3,Bt=M.getTriangle(),wt=M.getTriangle();mt[ft].distanceToSquared(N.start)<mt[et].distanceToSquared(N.end)?(Bt.a.copy(mt[ft]),Bt.b.copy(N.start),Bt.c.copy(N.end),wt.a.copy(mt[ft]),wt.b.copy(mt[et]),wt.c.copy(N.start)):(Bt.a.copy(mt[et]),Bt.b.copy(N.start),Bt.c.copy(N.end),wt.a.copy(mt[ft]),wt.b.copy(mt[et]),wt.c.copy(N.end)),V.a.copy(mt[K]),V.b.copy(N.end),V.c.copy(N.start),v(Bt)||x.push(Bt),v(wt)||x.push(wt),v(V)&&(x.splice(_,1),_--,G--)}else rt===3&&console.warn("TriangleClipper: Coplanar clip not handled")}}reset(){this.triangles.length=0,this.trianglePool.clear(),this.coplanarTriangleUsed=!1}}var Pt=nt(63284);function It(P){return P=~~P,P+4-P%4}class Vt{constructor(u,g=500){this.expansionFactor=1.5,this.type=u,this.length=0,this.array=null,this.setSize(g)}setType(u){if(this.length!==0)throw new Error("TypeBackedArray: Cannot change the type while there is used data in the buffer.");const g=this.array.buffer;this.array=new u(g),this.type=u}setSize(u){if(this.array&&u===this.array.length)return;const g=this.type,x=(0,Pt.EC)()?SharedArrayBuffer:ArrayBuffer,M=new g(new x(It(u*g.BYTES_PER_ELEMENT)));this.array&&M.set(this.array,0),this.array=M}expand(){const{array:u,expansionFactor:g}=this;this.setSize(u.length*g)}push(...u){let{array:g,length:x}=this;x+u.length>g.length&&(this.expand(),g=this.array);for(let M=0,_=u.length;M<_;M++)g[x+M]=u[M];this.length+=u.length}clear(){this.length=0}}class J{constructor(){this.groupAttributes=[{}],this.groupCount=0}getType(u){return this.groupAttributes[0][u].type}getItemSize(u){return this.groupAttributes[0][u].itemSize}getNormalized(u){return this.groupAttributes[0][u].normalized}getCount(u){if(this.groupCount<=u)return 0;const g=this.getGroupAttrArray("position",u);return g.length/g.itemSize}getTotalLength(u){const{groupCount:g,groupAttributes:x}=this;let M=0;for(let _=0;_<g;_++){const G=x[_];M+=G[u].length}return M}getGroupAttrSet(u=0){const{groupAttributes:g}=this;if(g[u])return this.groupCount=Math.max(this.groupCount,u+1),g[u];const x=g[0];for(this.groupCount=Math.max(this.groupCount,u+1);u>=g.length;){const M={};g.push(M);for(const _ in x){const G=x[_],V=new Vt(G.type);V.itemSize=G.itemSize,V.normalized=G.normalized,M[_]=V}}return g[u]}getGroupAttrArray(u,g=0){const{groupAttributes:x}=this;if(!x[0][u])throw new Error(`TypedAttributeData: Attribute with "${u}" has not been initialized`);return this.getGroupAttrSet(g)[u]}initializeArray(u,g,x,M){const{groupAttributes:_}=this,V=_[0][u];if(V){if(V.type!==g)for(let R=0,z=_.length;R<z;R++){const q=_[R][u];q.setType(g),q.itemSize=x,q.normalized=M}}else for(let R=0,z=_.length;R<z;R++){const q=new Vt(g);q.itemSize=x,q.normalized=M,_[R][u]=q}}clear(){this.groupCount=0;const{groupAttributes:u}=this;u.forEach(g=>{for(const x in g)g[x].clear()})}delete(u){this.groupAttributes.forEach(g=>{delete g[u]})}reset(){this.groupAttributes=[],this.groupCount=0}}class At{constructor(){this.intersectionSet={},this.ids=[]}add(u,g){const{intersectionSet:x,ids:M}=this;x[u]||(x[u]=[],M.push(u)),x[u].push(g)}}var kt=nt(48655);const xt=new h.Ray,ee=new h.Matrix4,yt=new h.Triangle,_t=new h.Vector3,Ct=new h.Vector4,Zt=new h.Vector4,pt=new h.Vector4,Rt=new h.Vector4,Wt=new h.Vector4,oe=new h.Vector4,de=new h.Line3,Ne=new h.Vector3,Fe=1e-8,$t=1e-15,Mt=-1,Lt=1,Ot=-2,Gt=2,pe=0,he=1,Se=2,be=1e-14;let le=null;function ve(P){le=P}function Ye(P,u){P.getMidpoint(xt.origin),P.getNormal(xt.direction);const g=u.raycastFirst(xt,h.DoubleSide);return!!(g&&xt.direction.dot(g.face.normal)>0)?Mt:Lt}function ke(P,u){function g(){return Math.random()-.5}P.getNormal(Ne),xt.direction.copy(Ne),P.getMidpoint(xt.origin);const x=3;let M=0,_=1/0;for(let G=0;G<x;G++){xt.direction.x+=g()*Fe,xt.direction.y+=g()*Fe,xt.direction.z+=g()*Fe,xt.direction.multiplyScalar(-1);const V=u.raycastFirst(xt,h.DoubleSide);if(!!(V&&xt.direction.dot(V.face.normal)>0)&&M++,V!==null&&(_=Math.min(_,V.distance)),_<=$t)return V.face.normal.dot(Ne)>0?Gt:Ot;if(M/x>.5||(G-M+1)/x>.5)break}return M/x>.5?Mt:Lt}function ln(P,u){const g=new At,x=new At;return ee.copy(P.matrixWorld).invert().multiply(u.matrixWorld),P.geometry.boundsTree.bvhcast(u.geometry.boundsTree,ee,{intersectsTriangles(M,_,G,V){if(!v(M)&&!v(_)){let R=M.intersectsTriangle(_,de,!0);if(!R){const z=M.plane,q=_.plane,rt=z.normal,ct=q.normal;rt.dot(ct)===1&&Math.abs(z.constant-q.constant)<be&&(R=!0)}if(R){let z=P.geometry.boundsTree.resolveTriangleIndex(G),q=u.geometry.boundsTree.resolveTriangleIndex(V);g.add(z,q),x.add(q,z),le&&(le.addEdge(de),le.addIntersectingTriangles(G,M,V,_))}}return!1}}),{aIntersections:g,bIntersections:x}}function Oe(P,u,g,x,M,_,G=!1){const V=g.attributes,R=g.index,z=P*3,q=R.getX(z+0),rt=R.getX(z+1),ct=R.getX(z+2);for(const at in _){const gt=V[at],bt=_[at];if(!(at in V))throw new Error(`CSG Operations: Attribute ${at} not available on geometry.`);const mt=gt.itemSize;at==="position"?(yt.a.fromBufferAttribute(gt,q).applyMatrix4(x),yt.b.fromBufferAttribute(gt,rt).applyMatrix4(x),yt.c.fromBufferAttribute(gt,ct).applyMatrix4(x),Ge(yt.a,yt.b,yt.c,u,3,bt,G)):at==="normal"?(yt.a.fromBufferAttribute(gt,q).applyNormalMatrix(M),yt.b.fromBufferAttribute(gt,rt).applyNormalMatrix(M),yt.c.fromBufferAttribute(gt,ct).applyNormalMatrix(M),G&&(yt.a.multiplyScalar(-1),yt.b.multiplyScalar(-1),yt.c.multiplyScalar(-1)),Ge(yt.a,yt.b,yt.c,u,3,bt,G,!0)):(Ct.fromBufferAttribute(gt,q),Zt.fromBufferAttribute(gt,rt),pt.fromBufferAttribute(gt,ct),Ge(Ct,Zt,pt,u,mt,bt,G))}}function un(P,u,g,x,M,_,G,V=!1){ue(P,x,M,_,G,V),ue(V?g:u,x,M,_,G,V),ue(V?u:g,x,M,_,G,V)}function Ke(P,u,g=!1){switch(P){case kt.UC:if(u===Lt||u===Gt&&!g)return he;break;case kt.vC:if(g){if(u===Mt)return pe}else if(u===Lt||u===Ot)return he;break;case kt.BB:if(g){if(u===Lt||u===Ot)return he}else if(u===Mt)return pe;break;case kt.tD:if(u===Mt)return pe;if(u===Lt)return he;break;case kt.TP:if(u===Mt||u===Gt&&!g)return he;break;case kt.ZR:if(!g&&(u===Lt||u===Ot))return he;break;case kt.rZ:if(!g&&(u===Mt||u===Gt))return he;break;default:throw new Error(`Unrecognized CSG operation enum "${P}".`)}return Se}function Ge(P,u,g,x,M,_,G=!1,V=!1){const R=z=>{_.push(z.x),M>1&&_.push(z.y),M>2&&_.push(z.z),M>3&&_.push(z.w)};Rt.set(0,0,0,0).addScaledVector(P,x.a.x).addScaledVector(u,x.a.y).addScaledVector(g,x.a.z),Wt.set(0,0,0,0).addScaledVector(P,x.b.x).addScaledVector(u,x.b.y).addScaledVector(g,x.b.z),oe.set(0,0,0,0).addScaledVector(P,x.c.x).addScaledVector(u,x.c.y).addScaledVector(g,x.c.z),V&&(Rt.normalize(),Wt.normalize(),oe.normalize()),R(Rt),G?(R(oe),R(Wt)):(R(Wt),R(oe))}function ue(P,u,g,x,M,_=!1){for(const G in M){const V=u[G],R=M[G];if(!(G in u))throw new Error(`CSG Operations: Attribute ${G} no available on geometry.`);const z=V.itemSize;G==="position"?(_t.fromBufferAttribute(V,P).applyMatrix4(g),R.push(_t.x,_t.y,_t.z)):G==="normal"?(_t.fromBufferAttribute(V,P).applyNormalMatrix(x),_&&_t.multiplyScalar(-1),R.push(_t.x,_t.y,_t.z)):(R.push(V.getX(P)),z>1&&R.push(V.getY(P)),z>2&&R.push(V.getZ(P)),z>3&&R.push(V.getW(P)))}}class ye{constructor(u){this.triangle=new h.Triangle().copy(u),this.intersects={}}addTriangle(u,g){this.intersects[u]=new h.Triangle().copy(g)}getIntersectArray(){const u=[],{intersects:g}=this;for(const x in g)u.push(g[x]);return u}}class Je{constructor(){this.data={}}addTriangleIntersection(u,g,x,M){const{data:_}=this;_[u]||(_[u]=new ye(g)),_[u].addTriangle(x,M)}getTrianglesAsArray(u=null){const{data:g}=this,x=[];if(u!==null)u in g&&x.push(g[u].triangle);else for(const M in g)x.push(g[M].triangle);return x}getTriangleIndices(){return Object.keys(this.data).map(u=>parseInt(u))}getIntersectionIndices(u){const{data:g}=this;return g[u]?Object.keys(g[u].intersects).map(x=>parseInt(x)):[]}getIntersectionsAsArray(u=null,g=null){const{data:x}=this,M=new Set,_=[],G=V=>{if(x[V])if(g!==null)x[V].intersects[g]&&_.push(x[V].intersects[g]);else{const R=x[V].intersects;for(const z in R)M.has(z)||(M.add(z),_.push(R[z]))}};if(u!==null)G(u);else for(const V in x)G(V);return _}reset(){this.data={}}}class Xt{constructor(){this.enabled=!1,this.triangleIntersectsA=new Je,this.triangleIntersectsB=new Je,this.intersectionEdges=[]}addIntersectingTriangles(u,g,x,M){const{triangleIntersectsA:_,triangleIntersectsB:G}=this;_.addTriangleIntersection(u,g,x,M),G.addTriangleIntersection(x,M,u,g)}addEdge(u){this.intersectionEdges.push(u.clone())}reset(){this.triangleIntersectsA.reset(),this.triangleIntersectsB.reset(),this.intersectionEdges=[]}init(){this.enabled&&(this.reset(),ve(this))}complete(){this.enabled&&ve(null)}}const ne=new h.Matrix4,Pe=new h.Matrix3,Ut=new h.Triangle,Ie=new h.Triangle,lt=new h.Triangle,te=new h.Triangle,Nt=[],Jt=[];function Me(P){for(const u of P)return u}function fn(P,u,g,x,M,_={}){const{useGroups:G=!0}=_,{aIntersections:V,bIntersections:R}=ln(P,u),z=[];let q=null,rt;return rt=G?0:-1,Ee(P,u,V,g,!1,x,M,rt),ge(P,u,V,g,!1,M,rt),g.findIndex(at=>at!==kt.rZ&&at!==kt.ZR)!==-1&&(rt=G?P.geometry.groups.length||1:-1,Ee(u,P,R,g,!0,x,M,rt),ge(u,P,R,g,!0,M,rt)),Nt.length=0,Jt.length=0,{groups:z,materials:q}}function Ee(P,u,g,x,M,_,G,V=0){const R=P.matrixWorld.determinant()<0;ne.copy(u.matrixWorld).invert().multiply(P.matrixWorld),Pe.getNormalMatrix(P.matrixWorld).multiplyScalar(R?-1:1);const z=P.geometry.groupIndices,q=P.geometry.index,rt=P.geometry.attributes.position,ct=u.geometry.boundsTree,at=u.geometry.index,gt=u.geometry.attributes.position,bt=g.ids,mt=g.intersectionSet;for(let K=0,ft=bt.length;K<ft;K++){const et=bt[K],Bt=V===-1?0:z[et]+V,wt=3*et,Ft=q.getX(wt+0),Yt=q.getX(wt+1),qt=q.getX(wt+2);Ut.a.fromBufferAttribute(rt,Ft).applyMatrix4(ne),Ut.b.fromBufferAttribute(rt,Yt).applyMatrix4(ne),Ut.c.fromBufferAttribute(rt,qt).applyMatrix4(ne),_.reset(),_.initialize(Ut);const Ht=mt[et];for(let se=0,_e=Ht.length;se<_e;se++){const vt=3*Ht[se],ce=at.getX(vt+0),zt=at.getX(vt+1),Qt=at.getX(vt+2);Ie.a.fromBufferAttribute(gt,ce),Ie.b.fromBufferAttribute(gt,zt),Ie.c.fromBufferAttribute(gt,Qt),_.splitByTriangle(Ie)}const Ae=_.triangles;for(let se=0,_e=Ae.length;se<_e;se++){const vt=Ae[se],ce=_.coplanarTriangleUsed?ke(vt,ct):Ye(vt,ct);Nt.length=0,Jt.length=0;for(let zt=0,Qt=x.length;zt<Qt;zt++){const ie=Ke(x[zt],ce,M);ie!==Se&&(Jt.push(ie),Nt.push(G[zt].getGroupAttrSet(Bt)))}if(Nt.length!==0){Ut.getBarycoord(vt.a,te.a),Ut.getBarycoord(vt.b,te.b),Ut.getBarycoord(vt.c,te.c);for(let zt=0,Qt=Nt.length;zt<Qt;zt++){const ie=Nt[zt],Le=Jt[zt]===pe;Oe(et,te,P.geometry,P.matrixWorld,Pe,ie,R!==Le)}}}}return bt.length}function ge(P,u,g,x,M,_,G=0){const V=P.matrixWorld.determinant()<0;ne.copy(u.matrixWorld).invert().multiply(P.matrixWorld),Pe.getNormalMatrix(P.matrixWorld).multiplyScalar(V?-1:1);const R=u.geometry.boundsTree,z=P.geometry.groupIndices,q=P.geometry.index,rt=P.geometry.attributes,ct=rt.position,at=[],gt=P.geometry.halfEdges,bt=new Set,mt=(0,Pt.YU)(P.geometry);for(let K=0,ft=mt;K<ft;K++)K in g.intersectionSet||bt.add(K);for(;bt.size>0;){const K=Me(bt);bt.delete(K),at.push(K);const ft=3*K,et=q.getX(ft+0),Bt=q.getX(ft+1),wt=q.getX(ft+2);lt.a.fromBufferAttribute(ct,et).applyMatrix4(ne),lt.b.fromBufferAttribute(ct,Bt).applyMatrix4(ne),lt.c.fromBufferAttribute(ct,wt).applyMatrix4(ne);const Ft=Ye(lt,R);Jt.length=0,Nt.length=0;for(let Yt=0,qt=x.length;Yt<qt;Yt++){const Ht=Ke(x[Yt],Ft,M);Ht!==Se&&(Jt.push(Ht),Nt.push(_[Yt]))}for(;at.length>0;){const Yt=at.pop();for(let qt=0;qt<3;qt++){const Ht=gt.getSiblingTriangleIndex(Yt,qt);Ht!==-1&&bt.has(Ht)&&(at.push(Ht),bt.delete(Ht))}if(Nt.length!==0){const qt=3*Yt,Ht=q.getX(qt+0),Ae=q.getX(qt+1),se=q.getX(qt+2),_e=G===-1?0:z[Yt]+G;if(lt.a.fromBufferAttribute(ct,Ht),lt.b.fromBufferAttribute(ct,Ae),lt.c.fromBufferAttribute(ct,se),!v(lt))for(let vt=0,ce=Nt.length;vt<ce;vt++){const zt=Jt[vt],Qt=Nt[vt].getGroupAttrSet(_e),ie=zt===pe;un(Ht,Ae,se,rt,P.matrixWorld,Pe,Qt,ie!==V)}}}}}var Ve=nt(90980);function dn(P){for(let u=0;u<P.length-1;u++){const g=P[u],x=P[u+1];if(g.materialIndex===x.materialIndex){const M=g.start,_=x.start+x.count;x.start=M,x.count=_-M,P.splice(u,1),u--}}}function me(P,u,g,x){g.clear();const M=P.attributes;for(let _=0,G=x.length;_<G;_++){const V=x[_],R=M[V];g.initializeArray(V,R.array.constructor,R.itemSize,R.normalized)}for(const _ in g.attributes)x.includes(_)||g.delete(_);for(const _ in u.attributes)x.includes(_)||(u.deleteAttribute(_),u.dispose())}function xe(P,u,g){let x=!1,M=-1;const _=P.attributes,G=u.groupAttributes[0];for(const R in G){const z=u.getTotalLength(R),q=u.getType(R),rt=u.getItemSize(R),ct=u.getNormalized(R);let at=_[R];(!at||at.array.length<z)&&(at=new h.BufferAttribute(new q(z),rt,ct),P.setAttribute(R,at),x=!0);let gt=0;for(let bt=0,mt=Math.min(g.length,u.groupCount);bt<mt;bt++){const K=g[bt].index,{array:ft,type:et,length:Bt}=u.groupAttributes[K][R],wt=new et(ft.buffer,0,Bt);at.array.set(wt,gt),gt+=wt.length}at.needsUpdate=!0,M=z/at.itemSize}if(P.index){const R=P.index.array;if(R.length<M)P.index=null,x=!0;else for(let z=0,q=R.length;z<q;z++)R[z]=z}let V=0;P.clearGroups();for(let R=0,z=Math.min(g.length,u.groupCount);R<z;R++){const{index:q,materialIndex:rt}=g[R],ct=u.getCount(q);ct!==0&&(P.addGroup(V,ct,rt),V+=ct)}P.setDrawRange(0,M),P.boundsTree=null,x&&P.dispose()}function fe(P,u){let g=u;return Array.isArray(u)||(g=[],P.forEach(x=>{g[x.materialIndex]=u})),g}class Ce{constructor(){this.triangleSplitter=new it,this.attributeData=[],this.attributes=["position","uv","normal"],this.useGroups=!0,this.consolidateGroups=!0,this.debug=new Xt}getGroupRanges(u){return!this.useGroups||u.groups.length===0?[{start:0,count:1/0,materialIndex:0}]:u.groups.map(g=>Be({},g))}evaluate(u,g,x,M=new Ve.B){let _=!0;if(Array.isArray(x)||(x=[x]),Array.isArray(M)||(M=[M],_=!1),M.length!==x.length)throw new Error("Evaluator: operations and target array passed as different sizes.");u.prepareGeometry(),g.prepareGeometry();const{triangleSplitter:G,attributeData:V,attributes:R,useGroups:z,consolidateGroups:q,debug:rt}=this;for(;V.length<M.length;)V.push(new J);M.forEach((K,ft)=>{me(u.geometry,K.geometry,V[ft],R)}),rt.init(),fn(u,g,x,G,V,{useGroups:z}),rt.complete();const ct=this.getGroupRanges(u.geometry),at=fe(ct,u.material),gt=this.getGroupRanges(g.geometry),bt=fe(gt,g.material);gt.forEach(K=>K.materialIndex+=at.length);let mt=[...ct,...gt].map((K,ft)=>an(Be({},K),{index:ft}));if(z){const K=[...at,...bt];q&&(mt=mt.map(et=>{const Bt=K[et.materialIndex];return et.materialIndex=K.indexOf(Bt),et}).sort((et,Bt)=>et.materialIndex-Bt.materialIndex));const ft=[];for(let et=0,Bt=K.length;et<Bt;et++){let wt=!1;for(let Ft=0,Yt=mt.length;Ft<Yt;Ft++){const qt=mt[Ft];qt.materialIndex===et&&(wt=!0,qt.materialIndex=ft.length)}wt&&ft.push(K[et])}M.forEach(et=>{et.material=ft})}else mt=[{start:0,count:1/0,index:0,materialIndex:0}],M.forEach(K=>{K.material=at[0]});return M.forEach((K,ft)=>{const et=K.geometry;xe(et,V[ft],mt),q&&dn(et.groups)}),_?M:M[0]}evaluateHierarchy(u,g=new Ve.B){u.updateMatrixWorld(!0);const x=(_,G)=>{const V=_.children;for(let R=0,z=V.length;R<z;R++){const q=V[R];q.isOperationGroup?x(q,G):G(q)}},M=_=>{const G=_.children;let V=!1;for(let z=0,q=G.length;z<q;z++){const rt=G[z];V=M(rt)||V}const R=_.isDirty();if(R&&_.markUpdated(),V&&!_.isOperationGroup){let z;return x(_,q=>{z?z=this.evaluate(z,q,q.operation):z=this.evaluate(_,q,q.operation)}),_._cachedGeometry=z.geometry,_._cachedMaterials=z.material,!0}else return V||R};return M(u),g.geometry=u._cachedGeometry,g.material=u._cachedMaterials,g}reset(){this.triangleSplitter.reset()}}},48655:function(jt,Tt,nt){nt.d(Tt,{BB:function(){return Kt},TP:function(){return St},UC:function(){return h},ZR:function(){return ut},rZ:function(){return v},tD:function(){return dt},vC:function(){return Dt}});const h=0,Dt=1,Kt=2,St=3,dt=4,ut=5,v=6},63284:function(jt,Tt,nt){nt.d(Tt,{BB:function(){return dt},EC:function(){return Dt},YU:function(){return v},ik:function(){return Kt}});var h=nt(99477);function Dt(){return typeof SharedArrayBuffer!="undefined"}function Kt(D){if(D.buffer instanceof SharedArrayBuffer)return D;const X=D.constructor,Z=D.buffer,$=new SharedArrayBuffer(Z.byteLength),N=new Uint8Array(Z);return new Uint8Array($).set(N,0),new X($)}function St(D,X=ArrayBuffer){return D>65535?new Uint32Array(new X(4*D)):new Uint16Array(new X(2*D))}function dt(D,X){if(!D.index){const Z=D.attributes.position.count,$=X.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,N=St(Z,$);D.setIndex(new h.BufferAttribute(N,1));for(let O=0;O<Z;O++)N[O]=O}}function ut(D){return D.index?D.index.count:D.attributes.position.count}function v(D){return ut(D)/3}},39714:function(jt,Tt,nt){nt.d(Tt,{h:function(){return ut}});var h=nt(99477),Dt=nt(88131),Kt=nt(14928);const St=1e-15;function dt(v){return Math.abs(v)<St}class ut extends h.Triangle{constructor(...D){super(...D),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new h.Vector3),this.satBounds=new Array(4).fill().map(()=>new Dt.B),this.points=[this.a,this.b,this.c],this.sphere=new h.Sphere,this.plane=new h.Plane,this.needsUpdate=!0}intersectsSphere(D){return(0,Kt.s_)(D,this)}update(){const D=this.a,X=this.b,Z=this.c,$=this.points,N=this.satAxes,O=this.satBounds,j=N[0],Y=O[0];this.getNormal(j),Y.setFromPoints(j,$);const ot=N[1],st=O[1];ot.subVectors(D,X),st.setFromPoints(ot,$);const tt=N[2],it=O[2];tt.subVectors(X,Z),it.setFromPoints(tt,$);const Pt=N[3],It=O[3];Pt.subVectors(Z,D),It.setFromPoints(Pt,$),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(j,D),this.needsUpdate=!1}}ut.prototype.closestPointToSegment=function(){const v=new h.Vector3,D=new h.Vector3,X=new h.Line3;return function($,N=null,O=null){const{start:j,end:Y}=$,ot=this.points;let st,tt=1/0;for(let it=0;it<3;it++){const Pt=(it+1)%3;X.start.copy(ot[it]),X.end.copy(ot[Pt]),(0,Kt.UX)(X,$,v,D),st=v.distanceToSquared(D),st<tt&&(tt=st,N&&N.copy(v),O&&O.copy(D))}return this.closestPointToPoint(j,v),st=j.distanceToSquared(v),st<tt&&(tt=st,N&&N.copy(v),O&&O.copy(j)),this.closestPointToPoint(Y,v),st=Y.distanceToSquared(v),st<tt&&(tt=st,N&&N.copy(v),O&&O.copy(Y)),Math.sqrt(tt)}}(),ut.prototype.intersectsTriangle=function(){const v=new ut,D=new Array(3),X=new Array(3),Z=new Dt.B,$=new Dt.B,N=new h.Vector3,O=new h.Vector3,j=new h.Vector3,Y=new h.Vector3,ot=new h.Vector3,st=new h.Line3,tt=new h.Line3,it=new h.Line3,Pt=new h.Vector3;function It(Vt,J,At){const kt=Vt.points;let xt=0,ee=-1;for(let yt=0;yt<3;yt++){const{start:_t,end:Ct}=st;_t.copy(kt[yt]),Ct.copy(kt[(yt+1)%3]),st.delta(O);const Zt=dt(J.distanceToPoint(_t));if(dt(J.normal.dot(O))&&Zt){At.copy(st),xt=2;break}const pt=J.intersectLine(st,Pt);if(!pt&&Zt&&Pt.copy(_t),(pt||Zt)&&!dt(Pt.distanceTo(Ct))){if(xt<=1)(xt===1?At.start:At.end).copy(Pt),Zt&&(ee=xt);else if(xt>=2){(ee===1?At.start:At.end).copy(Pt),xt=2;break}if(xt++,xt===2&&ee===-1)break}}return xt}return function(J,At=null,kt=!1){this.needsUpdate&&this.update(),J.isExtendedTriangle?J.needsUpdate&&J.update():(v.copy(J),v.update(),J=v);const xt=this.plane,ee=J.plane;if(Math.abs(xt.normal.dot(ee.normal))>1-1e-10){const yt=this.satBounds,_t=this.satAxes;X[0]=J.a,X[1]=J.b,X[2]=J.c;for(let pt=0;pt<4;pt++){const Rt=yt[pt],Wt=_t[pt];if(Z.setFromPoints(Wt,X),Rt.isSeparated(Z))return!1}const Ct=J.satBounds,Zt=J.satAxes;D[0]=this.a,D[1]=this.b,D[2]=this.c;for(let pt=0;pt<4;pt++){const Rt=Ct[pt],Wt=Zt[pt];if(Z.setFromPoints(Wt,D),Rt.isSeparated(Z))return!1}for(let pt=0;pt<4;pt++){const Rt=_t[pt];for(let Wt=0;Wt<4;Wt++){const oe=Zt[Wt];if(N.crossVectors(Rt,oe),Z.setFromPoints(N,D),$.setFromPoints(N,X),Z.isSeparated($))return!1}}return At&&(kt||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),At.start.set(0,0,0),At.end.set(0,0,0)),!0}else{const yt=It(this,ee,tt);if(yt===1&&J.containsPoint(tt.end))return At&&(At.start.copy(tt.end),At.end.copy(tt.end)),!0;if(yt!==2)return!1;const _t=It(J,xt,it);if(_t===1&&this.containsPoint(it.end))return At&&(At.start.copy(it.end),At.end.copy(it.end)),!0;if(_t!==2)return!1;if(tt.delta(j),it.delta(Y),j.dot(Y)<0){let de=it.start;it.start=it.end,it.end=de}const Ct=tt.start.dot(j),Zt=tt.end.dot(j),pt=it.start.dot(j),Rt=it.end.dot(j),Wt=Zt<pt,oe=Ct<Rt;return Ct!==Rt&&pt!==Zt&&Wt===oe?!1:(At&&(ot.subVectors(tt.start,it.start),ot.dot(j)>0?At.start.copy(tt.start):At.start.copy(it.start),ot.subVectors(tt.end,it.end),ot.dot(j)<0?At.end.copy(tt.end):At.end.copy(it.end)),!0)}}}(),ut.prototype.distanceToPoint=function(){const v=new h.Vector3;return function(X){return this.closestPointToPoint(X,v),X.distanceTo(v)}}(),ut.prototype.distanceToTriangle=function(){const v=new h.Vector3,D=new h.Vector3,X=["a","b","c"],Z=new h.Line3,$=new h.Line3;return function(O,j=null,Y=null){const ot=j||Y?Z:null;if(this.intersectsTriangle(O,ot))return(j||Y)&&(j&&ot.getCenter(j),Y&&ot.getCenter(Y)),0;let st=1/0;for(let tt=0;tt<3;tt++){let it;const Pt=X[tt],It=O[Pt];this.closestPointToPoint(It,v),it=It.distanceToSquared(v),it<st&&(st=it,j&&j.copy(v),Y&&Y.copy(It));const Vt=this[Pt];O.closestPointToPoint(Vt,v),it=Vt.distanceToSquared(v),it<st&&(st=it,j&&j.copy(Vt),Y&&Y.copy(v))}for(let tt=0;tt<3;tt++){const it=X[tt],Pt=X[(tt+1)%3];Z.set(this[it],this[Pt]);for(let It=0;It<3;It++){const Vt=X[It],J=X[(It+1)%3];$.set(O[Vt],O[J]),(0,Kt.UX)(Z,$,v,D);const At=v.distanceToSquared(D);At<st&&(st=At,j&&j.copy(v),Y&&Y.copy(D))}}return Math.sqrt(st)}}()},14928:function(jt,Tt,nt){nt.d(Tt,{UX:function(){return Kt},s_:function(){return St}});var h=nt(99477);const Dt=function(){const dt=new h.Vector3,ut=new h.Vector3,v=new h.Vector3;return function(X,Z,$){const N=X.start,O=dt,j=Z.start,Y=ut;v.subVectors(N,j),dt.subVectors(X.end,X.start),ut.subVectors(Z.end,Z.start);const ot=v.dot(Y),st=Y.dot(O),tt=Y.dot(Y),it=v.dot(O),It=O.dot(O)*tt-st*st;let Vt,J;It!==0?Vt=(ot*st-it*tt)/It:Vt=0,J=(ot+Vt*st)/tt,$.x=Vt,$.y=J}}(),Kt=function(){const dt=new h.Vector2,ut=new h.Vector3,v=new h.Vector3;return function(X,Z,$,N){Dt(X,Z,dt);let O=dt.x,j=dt.y;if(O>=0&&O<=1&&j>=0&&j<=1){X.at(O,$),Z.at(j,N);return}else if(O>=0&&O<=1){j<0?Z.at(0,N):Z.at(1,N),X.closestPointToPoint(N,!0,$);return}else if(j>=0&&j<=1){O<0?X.at(0,$):X.at(1,$),Z.closestPointToPoint($,!0,N);return}else{let Y;O<0?Y=X.start:Y=X.end;let ot;j<0?ot=Z.start:ot=Z.end;const st=ut,tt=v;if(X.closestPointToPoint(ot,!0,ut),Z.closestPointToPoint(Y,!0,v),st.distanceToSquared(ot)<=tt.distanceToSquared(Y)){$.copy(st),N.copy(ot);return}else{$.copy(Y),N.copy(tt);return}}}}(),St=function(){const dt=new h.Vector3,ut=new h.Vector3,v=new h.Plane,D=new h.Line3;return function(Z,$){const{radius:N,center:O}=Z,{a:j,b:Y,c:ot}=$;if(D.start=j,D.end=Y,D.closestPointToPoint(O,!0,dt).distanceTo(O)<=N||(D.start=j,D.end=ot,D.closestPointToPoint(O,!0,dt).distanceTo(O)<=N)||(D.start=Y,D.end=ot,D.closestPointToPoint(O,!0,dt).distanceTo(O)<=N))return!0;const Pt=$.getPlane(v);if(Math.abs(Pt.distanceToPoint(O))<=N){const Vt=Pt.projectPoint(O,ut);if($.containsPoint(Vt))return!0}return!1}}()},88131:function(jt,Tt,nt){nt.d(Tt,{B:function(){return Dt}});var h=nt(99477);class Dt{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(dt,ut){let v=1/0,D=-1/0;for(let X=0,Z=dt.length;X<Z;X++){const N=dt[X][ut];v=N<v?N:v,D=N>D?N:D}this.min=v,this.max=D}setFromPoints(dt,ut){let v=1/0,D=-1/0;for(let X=0,Z=ut.length;X<Z;X++){const $=ut[X],N=dt.dot($);v=N<v?N:v,D=N>D?N:D}this.min=v,this.max=D}isSeparated(dt){return this.min>dt.max||dt.min>this.max}}Dt.prototype.setFromBox=function(){const St=new h.Vector3;return function(ut,v){const D=v.min,X=v.max;let Z=1/0,$=-1/0;for(let N=0;N<=1;N++)for(let O=0;O<=1;O++)for(let j=0;j<=1;j++){St.x=D.x*N+X.x*(1-N),St.y=D.y*O+X.y*(1-O),St.z=D.z*j+X.z*(1-j);const Y=ut.dot(St);Z=Math.min(Y,Z),$=Math.max(Y,$)}this.min=Z,this.max=$}}();const Kt=function(){const St=new Dt;return function(ut,v){const D=ut.points,X=ut.satAxes,Z=ut.satBounds,$=v.points,N=v.satAxes,O=v.satBounds;for(let j=0;j<3;j++){const Y=Z[j],ot=X[j];if(St.setFromPoints(ot,$),Y.isSeparated(St))return!1}for(let j=0;j<3;j++){const Y=O[j],ot=N[j];if(St.setFromPoints(ot,D),Y.isSeparated(St))return!1}}}()}}]);
